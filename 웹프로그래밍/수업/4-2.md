## Math 객체

<img width="993" alt="image" src="https://github.com/user-attachments/assets/b5903bdf-54c9-4ac8-a48b-b0a220391192">

## Array / Map / Set 객체
- Array : 값의 중복 허용
- Map : Key의 중복 허용 안하고, 값의 중복 허용
- Set : 값의 중복 허용 안함

<img width="601" alt="image" src="https://github.com/user-attachments/assets/cfc6be36-9ed3-45ff-9e8f-6aa6c448ad9e">

### Array 객체
new를 사용하는 것보다 [] 사용하여 직접 선언

<img width="1088" alt="image" src="https://github.com/user-attachments/assets/b527d8a1-45d2-4972-9d88-75045272a760">

<img width="817" alt="image" src="https://github.com/user-attachments/assets/6aa72401-1573-48f1-98b3-42fbbd59f679">

<img width="803" alt="image" src="https://github.com/user-attachments/assets/4804ef17-0c3e-423a-ae12-acca4f423411">

#### 스택과 큐
- Stack : LIFO(Last In First Out) 구조, array의 push, pop 메소드로 구현
- Queue : FIFO(First In First Out) 구조, array의 push, shift 메소드로 구현

<img width="622" alt="image" src="https://github.com/user-attachments/assets/963fe51b-1b34-463e-9aea-51d5cc3bd216">

#### splice method

<img width="813" alt="image" src="https://github.com/user-attachments/assets/7b551725-5b43-4fa4-b93c-4f81731a60a1">

#### forEach method
배열의 각 index마다 callback 함수 수행

<img width="807" alt="image" src="https://github.com/user-attachments/assets/a3d3a3ad-e1e4-4e01-995a-abdc99db8f8b">

#### map method
배열 index마다 callback 함수 실행
- return 값 : 배열

<img width="804" alt="image" src="https://github.com/user-attachments/assets/018063ef-4e26-46e9-94f1-abbf37461995">

#### some method
배열에 조건이 일치하는 원소가 있는지 검사

<img width="668" alt="image" src="https://github.com/user-attachments/assets/dfca61fb-5142-4f7a-b7e2-adda2e7f96b1">

#### filter mehtod
배열에서 원하는 원소들로 새로 구성된 array return

<img width="668" alt="image" src="https://github.com/user-attachments/assets/2ece83a5-fb03-4e97-9e98-98651f71b763">

#### sort method
기본은 배열 원소를 문자열로 취급하여 사전순 정렬

<img width="786" alt="image" src="https://github.com/user-attachments/assets/18317c76-158d-4071-b0be-784d3b965a76">

### Map 객체
key와 value의 set으로 관리되는 객체

<img width="693" alt="image" src="https://github.com/user-attachments/assets/a943ee6e-1c6d-41f8-8ae2-03e6e6e3da9b">

#### 예

<img width="617" alt="image" src="https://github.com/user-attachments/assets/273206ef-4e06-40ec-9191-42da28258781">

#### Map과 객체 literal({...})과의 차이
1. 임의의 형으로 key를 설정 가능 : 객체 literal에서는 key로 문자열만 사용 가능하나, map에서는 NaN도 key로 설정 가능
2. map의 사이즈 취득 가능 : map 객체에서는 size property를 통해 등록된 key / value의 개수를 구할 수 있으나, 객체 literal에서는 for 루프 등으로 객체를 조사하여 수동으로 count해야 함
3. clean map을 만들 수 있음 : 객체 literal에서는 그 실체가 object 객체 즉, object 객체의 property(키)가 존재함. 즉 빈 객체를 literal를 만든 시점에도 실제로는 비어 있지 않은 상태임

#### key 관련 주의점
1. key는 '===' 연산자로 비교

<img width="489" alt="image" src="https://github.com/user-attachments/assets/6f3dfc53-f8a7-4b01-a9e0-1663abdc64df">

2. key가 NaN인 경우 NaN === NaN 가능(원래 NaN은 자기 자신과 동등하지 않은 특별한 값으로, NaN != NaN이 true임)

<img width="391" alt="image" src="https://github.com/user-attachments/assets/d7db2153-5bf9-4a6b-ae31-f010faf7ae16">

3. 객체가 key인 경우 주의

<img width="403" alt="image" src="https://github.com/user-attachments/assets/10074be5-9d3d-4f6f-b9db-1be635470d4b">

<img width="356" alt="image" src="https://github.com/user-attachments/assets/59c677a1-7118-42e6-8423-c1e4f85b6756">
