# JavaScript 개요
## 객체지향 구문
### 객체의 상속 - Prototype Chain
부모 class를 super / base class, 자식 class를 sub / 상속 class라고 한다.

javascript의 상속은 prototype chain에 의해서 구현된다.

<img width="527" alt="image" src="https://github.com/user-attachments/assets/bcfe792e-4d31-4386-9d1e-fd65f9ecbe97">

자식 Dog의 prototype에 부모 Animal 객체를 연결시킨다.(1번)
- 자식 Dog의 prototype 객체와 부모 Animal의 prototype 객체가 연결되는데, 이 것을 prototype chain이라고 한다.

- prototype chain의 최종은 Object.prototype이다.

2번은 Animal 생성자를 현재의 this로 호출하라는 의미이다.
- 부모 생성자에 인수를 건네는 경우 'Animal.call(this, 'hoge', 'foo');'로 사용한다.

```
var Animal = function() {};

Animal.prototype = {
  walk : function() {
    console.log('종종...');
  }
};

var Dog = function() {
// 2번
  Animal.call(this);
};

// 1번
Dog.prototype = new Animal();

Dog.prototype.bark = function() {
  console.log('멍멍!!');
};

var d = new Dog();
d.walk();
d.bark();

/*
결과
종종...
멍멍!!
*/
```

<img width="358" alt="image" src="https://github.com/user-attachments/assets/62c6e7a6-4999-4092-8c38-1a8055ea6f70">

상속 관계는 동적으로 변경이 가능하다.
- 1번의 d1은 Animal 객체를 상속하지만, 2번은 d2는 SuperAnimal 객체를 상속하여, 동적으로 상속 관계를 변경할 수 있다.
- 5번은 d1.walk 실행결과는 '종종...'이 나온다.
  - 즉 prototype chain은 인스턴스 생성 시점에 고정되어 이후 상속 관계가 변경되어도 인스턴스 생성 시점의 상속 관계는 보존된다.
 
```
var Animal = function() {};
Animal.prototype = {
  walk : function() {
    console.log('종종...');
  }
};

var SuperAnimal = function() {};
SuperAnimal.prototype = {
  walk : function() {
    console.log('다다다닷!');
  }
};

var Dog = function() {};
// Animal 객체를 계승한다.
Dog.prototype = new Animal();
// 1번
var d1 = new Dog();
// 2번
dl.walk();

// SuperAnimal 객체를 계승한다.
Dog.prototype = new SuperAnimal();
// 3번
var d2 = new Dog();
// 4번
d2.walk();
// 5번
d1.walk();

/*
결과
종종...

다다다닷!

종종...
*/
```

객체의 타입은 아래와 같이 판정한다.
- constructor property
  - 생성자 함수를 return한다.(자식 생성자는 인식하지 못한다.)
 
```
// Animal class와 이를 계승한 Hamster class 준비
var Animal = function() {};
var Hamster = function() {};
Hamster.prototype = new Animal();

var a = new Animal();
var h = new Hamster();
console.log(a.constructor === Animal);
console.log(h.constructor === Animal);
console.log(h.constructor === Hamster);

/*
결과
true
true
false
*/
```

- instanceof 연산자(A instanceof B)
  - 객체(A)가 특정 생성자(B)에 의해 생성된 인스턴스인지 판단한다.
 
```
console.log(h instanceof Animal);
console.log(h instanceof Hamster);

/*
결과
true
true
*/
```

- isPrototypeOf 연산자
  - 객체가 참조하는 prototype을 확인한다.
 
```
console.log(Hamster.prototype.isProptotypeOf(h));
console.log(Animal.prototype.isProptotypeOf(h));

/*
결과
true
true
*/
```

- in 연산자
  - 멤버의 유무를 판정한다.
 
```
var obj = {hoge : function() [], foo : function() {});

console.log('hoge' in obj);
console.log('piyo' in obj);

/*
결과
true
false
*/
```

### 객체 고급
private 멤버를 정의한다.
- private 멤버
  - class 내부의 메소드에서만 호출할 수 있는 property / 메소드이다.
 
- public 멤버
  - class 내외로부터 자유롭게 access 가능한 멤버이다.
 
```
// Constructor Triangle 함수에서 var로 변수 선언하면 local variable로 인식되어 외부에서 access가 불가능하다.
function Triangle() {
  // private property를 정의한다.(밑변 / 높이를 보존한다.)
  var _base;
  var _height;
  // private 메소드를 정의한다.(인수가 올바른 숫자인가를 체크한다.)
  var _checkArgs = function(val) {
    return (typeof var === 'Number' && val > 0);
  }

  // private 멤버에 엑세스하기 위한 메소드를 정의한다.
  this.setBase = function(base) {
    if(_checkArgs(base)) {_base = base;}
  }
  this.getBase = function() {return _base;}

  this.setHeigth = function(height) {
    if(_checkArgs(height)) {_height = height;}
  }
  this.getHeigth = funtion() {return height;}
}

// private 멤버에 access하지 않는 보통의 메소드를 정의한다.
Triangle.prototype.getArea = function() {
  return this.getBase() * this.getHeight() / 2;
}

var t = new Triangle();
t._base = 10;
t._height = 2;
console.log('삼각형의 면적:' + t.getArea());

t.setBase(10);
t.setHeight(2);
console.log('삼각형의 밑변:' + t.getBase());
console.log('삼각형의 높이:' + t.getHeight());
console.log('삼각형의 넓이:' + t.getArea());

/*
결과
NaN

삼각형의 밑변:10
삼각형의 높이:2
삼각형의 넓이:10
*/
```

private 멤버는 생성자 함수에서 정의하고, var 키워드를 사용한다.
- var 변수로 선언하면 local scope을 가져 외부에서 접근이 불가능하다.

priviledged 메소드를 정의해 private 멤버에 access한다.
- priviledged 메소드
  - priavte 멤버에 acess 할 수 있는 메소드이다.
 
- Accessor 메소드 공유로 property를 공개한다.(getter / setter 메소드)

<img width="434" alt="image" src="https://github.com/user-attachments/assets/6d0d01cb-593f-46c6-9070-69ef9d44c283">

Object.defineProperty 메소드로 proerty accessor 메소드 구현이 가능하다.

```
function Triangle() {
  // private 변수를 선언한다.
  var _base;
  var _height;

  // base property를 정의한다.
  Object.defineProperty(
    this,
    'base',
    {
      get : function() {
        return _base;
      },
      set : function(base) {
        if(typeof base === 'number' && base > 0) {
          _base = base;
        }
      }
    }
  };

  // height property를 정의한다.
  Object.defineProperty(
    this,
    'height',
    {
      get : function() {
        return _height;
      },
      set : function(height) {
        if(typeof height === 'number' && height > 0) {
          _height = height;
        }
      }
    }
  };
};

Triangle.prototype.getArea = function() {
  return this.base * this.height / 2;
};

var t = new Triangle();
t.base = 10;
t.height = 2;
console.log('삼각형의 밑변:' + t.base);
console.log('삼각형의 높이:' + t.height);
console.log('삼각형의 넓이:' + t.getArea());

/*
결과
삼각형의 밑변:10
삼각형의 높이:2
삼각형의 넓이:10
*/
```

여러 property를 함께 정의할 수 있다.

```
Object.defineProperties(this, {
  base : {
    get : function() {
      return _base;
    },
    set : function(base) {
      if(typeof base === 'number' && base > 0) {
        _base = base;
      }
    }
  },
  height : {
    get : function() {
      return _height;
    },
    set : function(height) {
      if(typeof height === 'number' && height > 0) {
        _height = height;
      }
    }
  }
});
```

네임스페이스(패키지)를 작성한다.
- class들을 구분하기 위한 공간이다.

<img width="522" alt="image" src="https://github.com/user-attachments/assets/104b4a06-7cea-4e18-ae55-7d33a32dcbf0">

- 네임스페이는 아래와 같이 빈 객체인 {}를 생성하여 정의한다.

```
var Wings = Wings || {};

Wings.Member = function(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
};

Wings.Member.prototype = {
  getName : function() {
    return this.lastName + ' ' + this.firstName;
  }
};

var mem = new Wings.Member('인식', '정');
console.log(mem.getName());
```

### ES2015의 객체지향 구문
#### Class 정의하기 - Class 명령
생성자의 이름은 constructor로 고정이다.

javascript에서는 생성자 / 메소드 생성시 public / protected / private와 같은 access 한정자를 선언할 수 없다.(public만 선언 가능하다.)

```
class Member {
  // 생성자
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  // 메소드
  getName() {
    return this.lastName + this.firstName;
  }
}

let m = new Member('시온', '정');
console.log(m.getName());

/*
결과
정시온
*/
```

class는 function 생성자와 다르다.
- class로 정의된 class는 내부적으로는 함수로, 기존 Function 객체로 표현했던 class(생성자)를 보다 알기 쉽게 표현한 것이다.
- 함수로서 호출은 불가능하다.

```
// new 연산자가 없다.
let m = Member('시온', '정')

/*
결과
Class constructor Member cannot be invoked without 'new'
*/
```

- class를 정의하기 전에 class를 호출하지 못한다.

```
let m = new Member('시온', '정');

class Member {...};

/*
결과
Member is not defined
*/
```

class property는 get / set 구문을 사용하여 정의가 가능하다.

```
class Member {
  // 생성자
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  // firstName property
