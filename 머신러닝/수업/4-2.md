# Combining Datasets : Concat and Append
데이터를 다룰 때 가장 많이하는 작업은 다른 소스의 데이터를 결합는 것

dataframe은 기본적으로 SQL같은 table 구조를 가지고 있기 때문에 SQL처럼 데이터를 병합하는 작업을 할 수 있고, 매우 효율적으로 작동함

series와 dataframe은 `pd.concat`을 통해서 결합할 수 있음

dataframe을 편하게 만들도록 아래의 함수를 미리 정의
```
def make_df(cols, ind):
    """Quickly make a DataFrame"""
    data = {c: [str(c) + str(i) for i in ind]
            for c in cols}
    return pd.DataFrame(data, ind)

# example DataFrame
make_df('ABC', range(3))

"""
결과
    A   B   C
0  A0  B0  C0
1  A1  B1  C1
2  A2  B2  C2
"""
```

jupyter에서는 하나의 dataframe을 보여주는 것이 기본이기 때문에, 여러개의 dataframe을 나란히 표시하는 클래도 정의

jupyter의 \_repr_html_ method 사용
```
class display(object):
    """Display HTML representation of multiple objects"""
    template = """<div style="float: left; padding: 10px;">
    <p style='font-family:"Courier New", Courier, monospace'>{0}</p>{1}
    </div>"""
    def __init__(self, *args):
        self.args = args
        
    def _repr_html_(self):
        return '\n'.join(self.template.format(a, eval(a)._repr_html_())
                         for a in self.args)
    
    def __repr__(self):
        return '\n\n'.join(a + '\n' + repr(eval(a))
                           for a in self.args)
```

## Recall : Concatenation of NumPy Arrays
series와 dataframe의 concatenation은 numpy의 array concatenation인 np.concatenate와 매우 유사함
```
x = [1, 2, 3]
y = [4, 5, 6]
z = [7, 8, 9]
np.concatenate([x, y, z])

# axis를 키워드를 통해 연결될 축 정의
x = [[1, 2],
     [3, 4]]
np.concatenate([x, x], axis=1)

"""
결과
array([1, 2, 3, 4, 5, 6, 7, 8, 9])

array([[1, 2, 1, 2],
       [3, 4, 3, 4]])
"""
```

## Simple Concatenation with pd.concat
pandas에 존재하는 `pd.concat` 함수의 작동 방법은 np.concaneate와 비슷하지만, 훨신 다양한 기능을 제공함
```
pd.concat(objs, axis=0, join='outer', ignore_index=False, keys=None, 
          levels=None, names=None, verify_integrity=False, sort=False,
```

pd.concat은 series나 dataframe의 단순 연결을 위해 사용됨
```
ser1 = pd.Series(['A', 'B', 'C'], index=[1, 2, 3])
ser2 = pd.Series(['D', 'E', 'F'], index=[4, 5, 6])
pd.concat([ser1, ser2])

# datframe도 연결 가능
df1 = make_df('AB', [1, 2])
df2 = make_df('AB', [3, 4])
display('df1', 'df2', 'pd.concat([df1, df2])')

# 기본적으로 이러한 연결은 옵션을 지정하지 않으면 행 단위로 이루어짐
# axis를 통해 다른 축으로 연결 가능
df3 = make_df('AB', [0, 1])
df4 = make_df('CD', [0, 1])
display('df3', 'df4', "pd.concat([df3, df4], axis=1)") # or axis="column"

"""
결과
1    A
2    B
3    C
4    D
5    E
6    F
dtype: object

df1
A	B
1	A1	B1
2	A2	B2

df2
A	B
3	A3	B3
4	A4	B4

pd.concat([df1, df2])
A	B
1	A1	B1
2	A2	B2
3	A3	B3
4	A4	B4

df3
A	B
0	A0	B0
1	A1	B1

df4
C	D
0	C0	D0
1	C1	D1

pd.concat([df3, df4], axis=1)
A	B	C	D
0	A0	B0	C0	D0
1	A1	B1	C1	D1
"""
```

### Duplicate Indices
np.concatenate와 pd.concat의 가장 중요한 차이는 결과에 중복 index가 있더라도 pandas의 경우 index가 유지된다는 것
```
x = make_df('AB', [0, 1])
y = make_df('AB', [2, 3])
y.index = x.index  # make duplicate indices!
display('x', 'y', 'pd.concat([x, y])')

"""
결과
x
A	B
0	A0	B0
1	A1	B1

y
A	B
0	A2	B2
1	A3	B3

pd.concat([x, y])
A	B
0	A0	B0
1	A1	B1
0	A2	B2
1	A3	B3
"""
```

#### Catching the Repeats as an Error
단순히 `pd.cooncat` 결과의 index가 겹치지 않는지 확인하려면 `verify_intergity` 플래그를 지정하면 됨

true로 설정하면 중복 index가 있는 경우 연결에서 예외 발생
```
try:
    pd.concat([x, y], verify_integrity=True)
except ValueError as e:
    print("ValueError:", e)

"""
결과
ValueError: Indexes have overlapping values: Index([0, 1], dtype='int64')
"""
```

#### Ignoring the Index
index 값 자체가 중요하지 않으면 단순히 무시하는 것이 좋음

이 옵션은 `ignore_index` 플래그를 사용하여 지정할 수 있음

이 값을 true로 설정하면 concatenate는 series 새로운 정수 index 생성
```
display('x', 'y', 'pd.concat([x, y], ignore_index=True)')

"""
결과
x
A	B
0	A0	B0
1	A1	B1

y
A	B
0	A2	B2
1	A3	B3

pd.concat([x, y], ignore_index=True)
A	B
0	A0	B0
1	A1	B1
2	A2	B2
3	A3	B3
"""
```

#### Adding MultiIndex Keys
또 다른 옵션은 `keys` 옵션을 사용하여 데이터 소스에 대한 레이블을 지정하는 것

결과는 데이터를 포함하는 multi index를 가짐
```
display('x', 'y', "pd.concat([x, y], keys=['x', 'y'])")

"""
결과
x
A	B
0	A0	B0
1	A1	B1

y
A	B
0	A2	B2
1	A3	B3

pd.concat([x, y], keys=['x', 'y'])
A	B
x	0	A0	B0
1	A1	B1
y	0	A2	B2
1	A3	B3
"""
```

### Concatenation with Joins
방금까지는 주로 dataframe을 같은 column label만 가진 경우을 고려함

그런데 실제로 서로 다른 소스의 데이터는 서로 다른 column name 집합을 가질 수 있음

`pd.concat`은 이 경우에도 여러 옵션을 제공함
```
df5 = make_df('ABC', [1, 2])
df6 = make_df('BCD', [3, 4])
display('df5', 'df6', 'pd.concat([df5, df6])')

"""
결과
df5
A	B	C
1	A1	B1	C1
2	A2	B2	C2

df6
B	C	D
3	B3	C3	D3
4	B4	C4	D4

pd.concat([df5, df6])
A	B	C	D
1	A1	B1	C1	NaN
2	A2	B2	C2	NaN
3	NaN	B3	C3	D3
4	NaN	B4	C4	D4
"""
```

기본적으로 데이터를 사용할 수 없는 항목은 NA 값으로 채워짐

이를 변경하기 위해 concatenate 함수의 `join` 및 `join_axes` 매개 변수에 대한 여러 옵션 중 하나를 지정할 수 있음

기본적으로 join은 outer가 기본임

하지만 inner로 변경하면, 겹치는 열만 사용해서 concatenate를 함
```
display('df5', 'df6',
        "pd.concat([df5, df6], join='inner')")

"""
결과
df5
A	B	C
1	A1	B1	C1
2	A2	B2	C2

df6
B	C	D
3	B3	C3	D3
4	B4	C4	D4

pd.concat([df5, df6], join='inner')
B	C
1	B1	C1
2	B2	C2
3	B3	C3
4	B4	C4
"""
```

## The append Method
직접 배열 연길이 매우 일반적이기 때문에 series 및 dataframe 객체에는 더 적은 키 입력으로 동일한 작업을 수행 할 수 있는 `append` 함수가 정의되어 있음

예를 들어 구버전에서는 `pd.concat([df1, df2])`를 호출하는 대신 단순히 `df1.append(df2)`를 호출할 수 있었음

하지만 지금은 작동하지 않음

python list의 `append` 및 `extend` method와 달리 pandas의 `append` method는 원래 객체를 수정하지 않고 대신 새 객체를 생성함

또한 새로운 index와 데이터 버퍼를 생성하기 때문에 그리 효율적인 방법이 아님

따라서 합친 이후 추가적인 처리를 하려는 경우는 dataframe list를 통해 concat 함수를 사용하는 것이 좋음

# Combining Datasets : Merge and Join
pandas의 강력함 중 하나는 아주 빠른 고성능인 메모리 merge와 join 구현에 있음

편의를 위해 아까 정의한 `display` 기능을 재정의
```
class display(object):
    """Display HTML representation of multiple objects"""
    template = """<div style="float: left; padding: 10px;">
    <p style='font-family:"Courier New", Courier, monospace'>{0}</p>{1}
    </div>"""
    def __init__(self, *args):
        self.args = args
        
    def _repr_html_(self):
        return '\n'.join(self.template.format(a, eval(a)._repr_html_())
                         for a in self.args)
    
    def __repr__(self):
        return '\n\n'.join(a + '\n' + repr(eval(a))
                           for a in self.args)
```

## Relational Algebra
`pd.merge`는 관계형 데이터를 조작하기 위한 공식적인 규칙인 relational algebra의 하위 집합임

또한 대부분의 데이터베이스에서 사용할 수 있는 기능과 같은 개념을 가짐

관계형 대수 접근 방식의 강점은 모든 데이터 세트에서 더 복잡한 연산의 구성 요소가 되는 몇 가지 기본 연산이 정의되어 있음

db와 pandas에서는 이러한 기본 연산을 통해 복잡한 연산을 단순화시킬 수 있음

pandas는 SQL의 병합 기능과 비슷한 기능을 `pd.merge`와 `pd.join` 두 가지로 정의함

## Categories of Joins
`pd.merge` 함수는 1 : 1, 1 : n, n : n join과 같은 여러가지 유형의 join을 구현함

세 가지 연산방식은 모두 `pd.merge` 인터페이스를 사용해서 수행할 수 있고, 입력하는 데이터의 형태에 따라 달라짐

### One - To - One Joins
이는 아까 다룬 column에 대한 concat과 비슷함
```
df1 = pd.DataFrame({'employee': ['Bob', 'Jake', 'Lisa', 'Sue'],
                    'group': ['Accounting', 'Engineering', 'Engineering', 'HR']})
df2 = pd.DataFrame({'employee': ['Lisa', 'Bob', 'Jake', 'Sue'],
                    'hire_date': [2004, 2008, 2012, 2014]})
display('df1', 'df2')

# pd.merge는 이를 employee 기준으로 병합
df3 = pd.merge(df1, df2)
df3

"""
결과
df1
  employee	      group
0	     Bob	 Accounting
1	    Jake	Engineering
2	    Lisa	Engineering
3	     Sue	         HR

df2
  employee	hire_date
0	    Lisa	     2004
1	     Bob	     2008
2	    Jake	     2012
3	     Sue	     2014
  
  employee	     group	hire_date
0	     Bob	 Accounting	     2008
1	    Jake	Engineering	     2012
2	    Lisa	Engineering	     2004
3	     Sue	         HR	     2014
"""
```

`pd.merge` 함수는 각 dataframe에 employee column이 있음을 인식하고 column을 key로 사용하여 자동으로 join함

그 결과로 두 dataframe이 결합된 새 dataframe을 return함

이 때 각 column의 항목 순서가 반드시 유지되는 것은 아님

또한 아주 특수한 경우를 제외하고 merge는 index를 삭제해서 정수 index를 새로 부여함

### Many - To - One Joins
두 key column 중 하나에 중복 항목이 포함 된 경우를 말함

dataframe은 해당 중복 항목을 적절하게 남겨 둠
```
df4 = pd.DataFrame({'group': ['Accounting', 'Engineering', 'HR'],
                    'supervisor': ['Carly', 'Guido', 'Steve']})
display('df3', 'df4', 'pd.merge(df3, df4)')

"""
결과
df3
  employee	     group	  hire_date
0	     Bob	 Accounting	       2008
1	    Jake	Engineering	       2012
2	    Lisa	Engineering	       2004
3	     Sue	         HR	       2014

df4
          group	  supervisor
0	   Accounting	       Carly
1	  Engineering	       Guido
2	           HR	       Steve

pd.merge(df3, df4)
  employee	      group	  hire_date	  supervisor
0	     Bob	 Accounting	       2008	       Carly
1	    Jake	Engineering	       2012	       Guido
2	    Lisa	Engineering	       2004	       Guido
3	     Sue	         HR	       2014	       Steve
"""
```

return된 dataframe에는 부서에 따른 "supervisor"의 정보가 모두 들어가 있음

Engineering은 두 명이 있으므로, 두 개에 같은 값(Guido)이 채워져있음

### Many - To - Many Joins
왼쪽 및 오른쪽 array의 key column에 모두 중복 항목이 포함된 경우 n : n 병합 수행
```
df5 = pd.DataFrame({'group': ['Accounting', 'Accounting',
                              'Engineering', 'Engineering', 'HR', 'HR'],
                    'skills': ['math', 'spreadsheets', 'coding', 'linux',
                               'spreadsheets', 'organization']})
display('df1', 'df5', "pd.merge(df1, df5)")

"""
결과
df1
  employee	      group
0	     Bob	 Accounting
1	    Jake	Engineering
2	    Lisa	Engineering
3	     Sue	         HR

df5
       group	        skills
0	Accounting	          math
1	Accounting	  spreadsheets
2	Engineering	        coding
3	Engineering	         linux
4	         HR	  spreadsheets
5	         HR	  organization

pd.merge(df1, df5)
  employee	      group	        skills
0	     Bob	 Accounting	          math
1	     Bob	 Accounting	  spreadsheets
2	    Jake	Engineering	        coding
3	    Jake	Engineering	         linux
4	    Lisa	Engineering	        coding
5	    Lisa	Engineering	         linux
6	     Sue	         HR	  spreadsheets
7	     Sue	         HR	  organization
```

### Specification of the Merge Key
`pd.merge`는 두 입력 사이에 하나 이상의 일치하는 column 이름을 찾고 이것을 key로 사용함

그러나 종종 column 이름이 너무 일치하지 않지만 같은 데이터인 경우가 있음

`pd.merge`는 이를 처리하기 위한 다양한 옵션을 제공함

#### The on Keyword
가장 간단하게는 column 이름 또는 column 이름 list를 on 키워드에 입력하여 병합 기준 column을 명시적으로 지정할 수 있음
```
display('df1', 'df2', "pd.merge(df1, df2, on='employee')")

"""
결과
df1
  employee	      group
0	     Bob	 Accounting
1	    Jake	Engineering
2	    Lisa	Engineering
3	     Sue	         HR

df2
  employee	hire_date
0	    Lisa	     2004
1	     Bob	     2008
2	    Jake	     2012
3	     Sue	     2014

pd.merge(df1, df2, on='employee')
  employee	      group	  hire_date
0	     Bob	 Accounting	       2008
1	    Jake	Engineering	       2012
2	    Lisa	Engineering	       2004
3	     Sue	         HR	       2014
"""
```

이 옵션은 왼쪽 및 오른쪽 dataframe 모두에 지정된 column과 같은 이름이 있는 경우에만 작동함

#### The left_on and right_on Keywords
때로는 column 이름이 다른 두 개의 데이터 세트를 병합할 수 있음

예를 들어 직원 이름이 "employee"가 아닌 "name"으로 되어있는 dataset의 경우 left_on과 right_on 키워드를 사용하여 각 dataframe의 열 이름을 지정할 수 있음
```
df3 = pd.DataFrame({'name': ['Bob', 'Jake', 'Lisa', 'Sue'],
                    'salary': [70000, 80000, 120000, 90000]})
display('df1', 'df3', 'pd.merge(df1, df3, left_on="employee", right_on="name")')

# 결과에는 원하는 경우 삭제할 수 있는 중복 column 존재
# 이런 경우 drop을 통해 삭제할 수 있음
pd.merge(df1, df3, left_on="employee", right_on="name").drop('name', axis=1)

"""
결과
df1
  employee	      group
0	     Bob	 Accounting
1	    Jake	Engineering
2	    Lisa	Engineering
3	     Sue	         HR

df3
  name	salary
0	 Bob	 70000
1	Jake	 80000
2	Lisa	120000
3	 Sue	 90000

pd.merge(df1, df3, left_on="employee", right_on="name")
  employee	      group	name	salary
0	     Bob	 Accounting	 Bob	 70000
1	    Jake	Engineering	Jake	 80000
2	    Lisa	Engineering	Lisa	120000
3	     Sue	         HR	 Sue	 90000

	employee	      group	salary
0	     Bob	 Accounting	 70000
1	    Jake	Engineering	 80000
2	    Lisa	Engineering	 120000
3	     Sue	         HR	 90000
"""
```

#### The left_index and right_index Keywords
