# Introducing Pandas Objects
## The Pandas Series Object
pandas series는 index를 가진 1차원 배열

다음과 같이 list 또는, np.array를 통해 만들 수 있음
```
data = pd.Series([0.25, 0.5, 0.75, 1.0])
data

"""
결과
0    0.25
1    0.50
2    0.75
3    1.00
dtype: float64
"""
```

series 값을 가진 `values`, 인덱스를 가진 `index` 두 가지로 구성되어 있음

`values`는 numpy의 배열
```
data.values

"""
결과
array([0.25, 0.5 , 0.75, 1.  ])
"""
```

`index`는 `pd.Index`라는 타입의 객체인데, 배열과 유사함
```
data.index

"""
결과
RangeIndex(start=0, stop=4, step=1)
"""
```

numpy 배열과 마찬가지로 braket을 통해 index로 데이터 조회 가능
```
data[1]

data[1:3]

"""
결과
np.float64(0.5)

1    0.50
2    0.75
dtype: float64
"""
```

### Series as generalized NumPy Array
numpy 배열에는 값에 엑세스하는데 사용되는 순서 기반의 정수 index가 있지만 series에는 값과 관련된 명시적으로 정의된 index 존재

이러한 index를 사용해서 series에서 array와 다른 추가 기능들을 사용할 수 있음
```
# index는 정수일 필요가 없고 원하는 유형의 값으로 구성될 수 있음
data = pd.Series([0.25, 0.5, 0.75, 1.0],
                 index=['a', 'b', 'c', 'd'])
data

data['b']

# 비연속적이거나 비순차적 index 사용 가능
data = pd.Series([0.25, 0.5, 0.75, 1.0],
                 index=[2, 5, 3, 7])
data

data[5]

"""
결과
a    0.25
b    0.50
c    0.75
d    1.00
dtype: float64

np.float64(0.5)

2    0.25
5    0.50
3    0.75
7    1.00
dtype: float64

np.float64(0.5)
"""
```

### Series as specialized Dictionary
위처럼 series는 array와 유사한 개념으로 볼 수 있음

하지만 다른 관점에서 보면, series는 python dictionary의 특수한 케이스이기도 함

dictionary는 임의의 key 값을 value 값으로 mapping

series는 이러한 map을 index - value pair가 수행함

그러한 측면에서 series는 dictionary의 다른 표현처럼 쓸 수 있지만 데이터 처리에 대해서는 dict보다 훨씬 빠름

아래처럼 dict을 통해서 series를 만들 수 있음
```
population_dict = {'California': 38332521,
                   'Texas': 26448193,
                   'New York': 19651127,
                   'Florida': 19552860,
                   'Illinois': 12882135}
population = pd.Series(population_dict)
population

# series는 dict처럼 access 가능
population['California']

# dict과 달리 series는 슬라이싱과 같은 배열 스타일 작업도 지원
population['California':'Illinois']

"""
결과
California    38332521
Texas         26448193
New York      19651127
Florida       19552860
Illinois      12882135
dtype: int64

np.int64(38332521)

California    38332521
Texas         26448193
New York      19651127
Florida       19552860
Illinois      12882135
dtype: int64
"""
```

### Constructing Series Objects
위에서 몇가지 series를 만드는 방법에 대해 알아봤는데, 모든 경우 아래의 형태를 약간씩 변형한 것
```
pd.Series(data, index = index)
```

index는 optional argument이고, data는 필수 argument임
```
# data는 list, numpy array 등을 받을 수 있는데, 이럴 경우 integer sequence가 기본 index가 됨
pd.Series([2, 4, 6])

# data는 한 개의 scalar 값을 가질 수 있으며, 이 경우 index를 명시하면 index의 수 만큼 반복해서 채워짐
pd.Series(5, index=[100, 200, 300])

# data는 dict일 수 있으며, 이 경우 index는 자동적으로 dict key가 됨
pd.Series({2:'a', 1:'b', 3:'c'})

# 모든 경우에 index를 명시적으로 정의해서 return되는 series의 형태를 바꿀 수 있음
pd.Series({2:'a', 1:'b', 3:'c'}, index=[3, 2])
# 이 경우 명시된 index만 series가 만들어지고, 나머지 index는 버려짐

"""
결과
0    2
1    4
2    6
dtype: int64

100    5
200    5
300    5
dtype: int64

2    a
1    b
3    c
dtype: object

3    c
2    a
dtype: object
```

## The Pandas DataFrame Object
직전에 설명한 `series`와 마찬가지로 `dataframe`은 numpy 배열의 일반화된 경우 또는 python dict의 특수한 경우로 생각할 수 있음

### DataFrame as a generalized NumPy Array
series가 index가 있는 1d array처럼 생각할 수 있다면, dataframe은 행(row) index와 열(column) 이름이 모두 있는 2d array로 생각할 수 있음

2d array를 1d array의 array로 볼 수 있는 것처럼, dataframe은 같은 index를 공유하는 series들의 모음으로 생각할 수 있음
```
area_dict = {'California': 423967, 'Texas': 695662, 'New York': 141297,
             'Florida': 170312, 'Illinois': 149995}
area = pd.Series(area_dict)
area

"""
결과
California    423967
Texas         695662
New York      141297
Florida       170312
Illinois      149995
dtype: int64
```

이전에 만든 population series와 방금 만든 area series를 합쳐서 dataframe을 만들어보자
```
states = pd.DataFrame({'population': population,
                       'area': area})
states

# series와 마찬가지로 dataframe에는 index 레이블을 조회하는 index attribute 존재
states.index

# 또한 dataframe에는 column 레이블을 조회하는 columns attribute 존재
states.columns

"""
결과
            population	area
California  38332521	423967
Texas       26448193	695662
New York    19651127	141297
Florida     19552860	170312
Illinois    12882135	149995

Index(['California', 'Texas', 'New York', 'Florida', 'Illinois'], dtype='object')

Index(['population', 'area'], dtype='object')
"""
```

### DataFrame as specialized Dictionary
마찬가지로 dataframe을 dict의 특수한 경우로 생각할 수 있음

dict의 key를 value에 mapping하듯, dataframe은 열 이름을 series에 mapping
```
states['area']

"""
결과
California    423967
Texas         695662
New York      141297
Florida       170312
Illinois      149995
Name: area, dtype: int64
"""
```

`dataframe`의 경우 `data['col0']`은 첫 번째 column 반환

### Constructing DataFrame Objects
dataframe은 다양한 방법으로 만들 수 있음

#### From a Single Series Object
dataframe은 series의 모음이므로, 열이 1개인 dataframe은 한 개의 series로 만들 수 있음
```
pd.DataFrame(population, columns=['population'])

"""
결과
            population
California  38332521
Texas       26448193
New York    19651127
Florida     19552860
Illinois    12882135
"""
```

#### From a List of Dict
list of dict을 통해서 dataframe을 만들 수 있음
```
data = [{'a': i, 'b': 2 * i}
        for i in range(3)]
print(data)
pd.DataFrame(data)

# 만약 key가 없으면 NaN을 채워줌
pd.DataFrame([{'a': 1, 'b': 2}, {'b': 3, 'c': 4}])

"""
결과
[{'a': 0, 'b': 0}, {'a': 1, 'b': 2}, {'a': 2, 'b': 4}]
   a  b
0  0  0
1  1  2
2  2  4

	  a	b	  c
0	1.0	2	NaN
1	NaN	3	4.0
```

#### From a Dictionary of Series Objects
dataframe은 dict of series로도 만들 수 있음
```
pd.DataFrame({'population': population,
              'area': area})

"""
결과
            population	area
California  38332521	423967
Texas       26448193	695662
New York    19651127	141297
Florida     19552860	170312
Illinois    12882135	149995
"""
```

#### From a Two - Dimensional NumPy Array
2차원 데이터 배열이 주어지면 지정된 열 및 index 이름으로 dataframe을 만들 수 있음

생략하면 정수 index가 사용됨
```
pd.DataFrame(np.random.rand(3, 2),
             #columns=['foo', 'bar'],
             index=['a', 'b', 'c'])

"""
결과
          0        1
a  0.640553 0.072974
b  0.774325 0.509881
c  0.237521 0.465482
"""
```

#### From a NumPy Structured Array
numpy는 structured array라는 것이 존재

dataframe은 structured array와 매유 유사하게 작동하며 다음 중 하나에서 직접 만들 수 있음
```
A = np.zeros(3, dtype=[('A', 'i8'), ('B', 'f8')])
A

pd.DataFrame(A)

"""
결과
array([(0, 0.), (0, 0.), (0, 0.)], dtype=[('A', '<i8'), ('B', '<f8')])


   A    B
0  0  0.0
1  0  0.0
2  0  0.0
"""
```

## The Pandas Index Object
위처럼 dataframe과 series 모두 index를 통해 데이터를 조회하고 변경할 수 있는 것을 확인

이 index는 pd.Index라는 자료형을 가짐
```
ind = pd.Index([2, 3, 5, 7, 11])
ind

"""
결과
Index([2, 3, 5, 7, 11], dtype='int64')
"""
```

### Index as Immutable Array
index는 주로 배열처럼 작동함
```
ind[1]

ind[::2]

# index 객체는 numpy 배열과 같은 많은 attribute를 가지고 있음
print(ind.size, ind.shape, ind.ndim, ind.dtype)

# index 객체와 numpy 배열의 가장 큰 차이점은 index는 일반적인 방법으로 수정 불가능
ind[1] = 0

"""
결과
np.int64(3)

Index([2, 5, 11], dtype='int64')

5 (5,) 1 int64

TypeError: Index does not support mutable operations
"""
```

### Index as Ordered Set
index 객체는 python의 내장 set 데이터 구조에서 사용되는 많은 규칙을 따르므로 union, intersection, difference, 혹은 기타 조합등의 집합 연산 수행 가능
```
indA = pd.Index([1, 3, 5, 7, 9])
indB = pd.Index([2, 3, 5, 7, 11])

indA.intersection(indB)  # intersection

indA.union(indB)  # union

indA.symmetric_difference(indB)  # symmetric difference

"""
결과
Index([3, 5, 7], dtype='int64')

Index([1, 2, 3, 5, 7, 9, 11], dtype='int64')

ndex([1, 2, 9, 11], dtype='int64')
"""
```

# Data Indexing and Selection
numpy array 값을 조회 및 수정하는 방법으로는 indexing, slicing, masking, fancy indexing 및 이들의 조합이 있음

여기에서는 series와 dataframe 자료형의 값을 조회하고 수정하는 방법을 알아보자

## Data Selection in Series
### Series as Dictionary
dict과 마찬가지로 series 객체는 key와 value간을 mapping해줌
```
data = pd.Series([0.25, 0.5, 0.75, 1.0],
                 index=['a', 'b', 'c', 'd'])
data

data['b']

# 또한 dict과 같은 python 표현식과 함수를 사용하여 key / value 값을 연산할 수 있음
'a' in data

data.keys()

list(data.items())

# series 객체는 dict과 유사한 구문으로 수정할 수도 있음
data['e'] = 1.25
data

"""
결과
a    0.25
b    0.50
c    0.75
d    1.00
dtype: float64

np.float64(0.5)

True

Index(['a', 'b', 'c', 'd'], dtype='object')

[('a', 0.25), ('b', 0.5), ('c', 0.75), ('d', 1.0)]

a    0.25
b    0.50
c    0.75
d    1.00
e    1.25
dtype: float64
"""
```

### Series as One - Dimensional Array
series는 이 dict과 같은 형태의 인터페이스를 기반으로 numpy 배열과 동일한 메커니즘(slice, masking, fancy indexing)으로 array와 같은 인터페이스를 쓸 수 있음
```
# slicing by explicit index
data['a':'c']

# slicing by implicit integer index
data[0:2]

# masking
data[(data > 0.3) & (data < 0.8)]

# fancy indexing
data[['a', 'e']]

"""
결과
a    0.25
b    0.50
c    0.75
dtype: float64

a    0.25
b    0.50
dtype: float64

b    0.50
c    0.75
dtype: float64

a    0.25
e    1.25
dtype: float64
"""
```

이 중에서 slicing은 주의해야 함

explicit index(data['a' : 'c'])를 사용하여 slicing 할 때 최종 index는 slice에 포함되는 반면, implicit index(data[0 : 2])를 사용하면 최종 index는 slice에서 제외됨

### Indexers : loc, iloc
이러한 slicing 및 index 규칙은 혼란스러움

예를 들어, series 정수 index가 있는 경우 data[1]과 같은 indexing 작업은 explicit index를 사용하고 data[1 : 3]과 같은 slicing 작업은 implicit index를 사용함
```
data = pd.Series(['a', 'b', 'c'], index=[1, 3, 5])
data

# explicit index when indexing
data[1]

# implicit index when slicing
data[1:3]

"""
결과
1    a
3    b
5    c
dtype: object

'a'

3    b
5    c
dtype: object
"""
```

정수 index의 경우 이러한 이유로 잠재적인 오류 요소가 있음

때문에 pandas는 특정 index 방식을 명시적으로 사용하는 특수 indexer method 제공

`loc`은 항상 explicit index를 참조하는 indexing 및 slicing 사용
```
data.loc[1

data.loc[1:3]

"""
결과
'a'

1    a
3    b
dtype: object
"""
```

`iloc`은 implicit index를 사용해서 indexing 및 slicing 사용
```
data.iloc[1]

data.iloc[1:3]

"""
결과
'b'

3    b
5    c
dtype: object
"""
```

## Data Selection in DataFrame
### DataFrame as a Dictionary
```
area = pd.Series({'California': 423967, 'Texas': 695662,
                  'New York': 141297, 'Florida': 170312,
                  'Illinois': 149995})
pop = pd.Series({'California': 38332521, 'Texas': 26448193,
                 'New York': 19651127, 'Florida': 19552860,
                 'Illinois': 12882135})
data = pd.DataFrame({'area':area, 'pop':pop})
data

# dataframe의 column을 구성하는 개별 series는 column 이름을 통해 dict처럼 access 가능
data['area']

# 유사하게 attribute - style으로 string column name을 사용해 조회 가능
data.area

# 위 두 가지는 대부분 완전히 동등한 결과를 줌
data.area is data['area']

# 다만 열 이름이 문자열이 아니거나 열 이름이 dataframe method와 충돌하는 경우 attribute style로 조회 불가
# dataframe에 pop() method 존재
data.pop is data['pop']

# dict - style을 사용하여 객체 연산 가능
data['density'] = data['pop'] / data['area']
data

"""
결과
              area	     pop
California  423967	38332521
Texas       695662	26448193
New York    141297	19651127
Florida     170312	19552860
Illinois    149995	12882135

California    423967
Texas         695662
New York      141297
Florida       170312
Illinois      149995
Name: area, dtype: int64

California    423967
Texas         695662
New York      141297
Florida       170312
Illinois      149995
Name: area, dtype: int64

True

False

              area	     pop	  density
California  423967	38332521	90.413926
Texas       695662	26448193	38.018740
New York    141297	19651127	139.076746
Florida     170312	19552860	114.806121
Illinois    149995	12882135	85.883763
"""
```

### DataFrame as Two - Dimensional Array
dataframe은 또한 2d array로 볼 수 있음

`values` attribute을 사용하여 np.array 형태의 배열로 확인할 수 있음
```
data.values

# matrix transpose 가능
data.T

"""
결과
array([[4.23967000e+05, 3.83325210e+07, 9.04139261e+01],
       [6.95662000e+05, 2.64481930e+07, 3.80187404e+01],
       [1.41297000e+05, 1.96511270e+07, 1.39076746e+02],
       [1.70312000e+05, 1.95528600e+07, 1.14806121e+02],
       [1.49995000e+05, 1.28821350e+07, 8.58837628e+01]])

           California	       Texas	    New York	     Florida	    Illinois
area     4.239670e+05	6.956620e+05	1.412970e+05	1.703120e+05	1.499950e+05
pop      3.833252e+07	2.644819e+07	1.965113e+07	1.955286e+07	1.288214e+07
density  9.041393e+01	3.801874e+01	1.390767e+02	1.148061e+02	8.588376e+01
"""
```

다만 dataframe objects의 조회 방식이 numpy array와 다르다는 것에 유의해야 함
```
# numpy array에 어떤 index를 입력하면 row 반환
data.values[0]

# 하나의 index를 dataframe에 입력하면 column 반환
data['area']

# 만약 array style indexing을 사용하기 위해서는 dict 형태의 indexing이 아니라 loc, iloc을 사용해야 함
# iloc indexer를 사용하면 단순한 numpy array처럼 indexing할 수 있지만 dataframe index 및 column 레이블이 유지되어서 반환
data.iloc[:3, :2]

# loc indexer를 사용하여 array와 유사한 스타일로 기본 데이터를 indexing하면 explicit index와 column name 사용
data.loc[:'Illinois', :'pop']

# loc indexer로 masking과 indexing 결합 가능
data.loc[data.density > 100, ['pop', 'density']]

# 이러한 indexing 규칙을 사용하여 값을 설정하거나 수정 가능
data.iloc[0, 2] = 90
display(data)

"""
결과
array([4.23967000e+05, 3.83325210e+07, 9.04139261e+01])

California    423967
Texas         695662
New York      141297
Florida       170312
Illinois      149995
Name: area, dtype: int64

              area	     pop
California  423967	38332521
Texas       695662	26448193
New York    141297	19651127

              area	     pop
California  423967	38332521
Texas       695662	26448193
New York    141297	19651127
Florida     170312	19552860
Illinois    149995	12882135

               pop	   density
New York  19651127	139.076746
Florida   19552860	114.806121

              area	     pop	  density
California  423967	38332521	90.000000
Texas       695662	26448193	38.018740
New York    141297	19651127	139.076746
Florida     170312	19552860	114.806121
Illinois    149995	12882135	85.883763
"""
```
### Additional Indexing Conventions
주의해야 할 점은 indexing은 열을 나타내고, slicing은 행을 나타낸다는 것
```
data['Florida':'Illinois']

# 정수형 index도 동일
data[1:3]

# 유사하게 masking도 row를 필터링하는데 사용
data[data.density > 100]

"""
결과
            area	     pop	   density
Florida   170312	19552860	114.806121
Illinois  149995	12882135	85.883763

            area	     pop	  density
Texas     695662	26448193	38.018740
New York  141297	19651127	139.076746

            area	     pop	   density
New York  141297	19651127	139.076746
Florida   170312	19552860	114.806121
"""
```

## Operating on Data in Pandas
numpy의 가장 큰 장점은 연산을 elementwise로 수행할 수 있다는 것

pandas는 이 기능의 대부분을 상속받아서 쓸 수 있음

하지만 더하기나 곱셈과 같은 다수의 값을 동시에 사용해야 하는 경우, pandas는 index 기준으로 정렬해서 인자로 사용함

즉, 같은 index의 값끼리 연산

### Ufuncs : Index Preservation
pandas는 numpy와 함께 작동하도록 설계되었기 때문에 모든 numpy의 ufuncs는 pandas series 및 dataframe 객체에서 작동함
```
rng = np.random.RandomState(42)
ser = pd.Series(rng.randint(0, 10, 4))
ser

df = pd.DataFrame(rng.randint(0, 10, (3, 4)),
                  columns=['A', 'B', 'C', 'D'])
df

# 이러한 object 중 하나에 numpy ufuncs를 적용하면 index가 유지된 결과 object 반환
np.exp(ser)

np.sin(df * np.pi / 4)

"""
결과
0    6
1    3
2    7
3    4
dtype: int64

   A  B  C  D
0  6  9  2  6
1  7  4  3  7
2  7  2  5  4

0     403.428793
1      20.085537
2    1096.633158
3      54.598150
dtype: float64

           A             B         C              D
0  -1.000000  7.071068e-01  1.000000  -1.000000e+00
1  -0.707107  1.224647e-16  0.707107  -7.071068e-01
2  -0.707107  1.000000e+00  -0.707107  1.224647e-16
"""
```

### Ufuncs : Index Alignment
두 개의 series 또는 dataframe object에 대한 연산의 경우 pandas는 연산을 수행하는 과정에서 index를 정렬함

#### Index Alignment in Series
```
area = pd.Series({'Alaska': 1723337, 'Texas': 695662,
                  'California': 423967}, name='area')
population = pd.Series({'California': 38332521, 'Texas': 26448193,
                        'New York': 19651127}, name='population')
population / area

# 결과 array의 index는 두 입력 array의 index의 union이 됨
area.index.union(population.index)

# python의 내장 산술 표현식에 대해 이러한 연산은 모두 동일하게 작동
A = pd.Series([2, 4, 6], index=[0, 1, 2])
B = pd.Series([1, 3, 5], index=[1, 2, 3])
A + B

# NaN 값을 사용하는 것이 바람직한 동작이 아닌 경우 연산자 대신 적절한 개체 메서드를 사용하여 기본적으로 채워 넣을 값을 설정할 수 있음
A.add(B, fill_value=0)

"""
결과
population / area
Alaska              NaN
California    90.413926
New York            NaN
Texas         38.018740
dtype: float64

Index(['Alaska', 'California', 'New York', 'Texas'], dtype='object')

0    NaN
1    5.0
2    9.0
3    NaN
dtype: float64

0    2.0
1    5.0
2    9.0
3    5.0
dtype: float64
"""
```

#### Index Alignment in DataFrame
dataframe 연산은 행과 열 모두 유사한 방식으로 정렬
```
A = pd.DataFrame(rng.randint(0, 20, (2, 2)),
                 columns=list('AB'))
A

B = pd.DataFrame(rng.randint(0, 10, (3, 3)),
                 columns=list('BAC'))
B

A + B

# series와 마찬가지로 누락된 항목 대신 사용할 값을 fill_value로 지정 가능
fill = A.stack().mean()
A.add(B, fill_value=fill)

"""
결과
   A   B
0  1  11
1  5   1

   B  A  C
0  4  0  9
1  5  8  0
2  9  2  6

     A      B    C
0  1.0   15.0  NaN
1  13.0  6.0   NaN
2  NaN   NaN   NaN

     A     B     C
0  1.0  15.0  13.5
1  13.0  6.0   4.5
2  6.5  13.5  10.5
"""
```

### Ufuncs : Operations Between DataFrame and Series
dataframe과 series 사이에서 연산을 수행할 때 index 및 열 정렬은 최대한 유사하게 유지됨
```
A = rng.randint(10, size=(3, 4))
A

A - A[0]

# 2d array와 1d array 사이의 빼기는 row마다 반복적으로 이루어짐
df = pd.DataFrame(A, columns=list('QRST'))
df - df.iloc[0]

# 이것을 열에 대해 반복적으로 수행하려면 객체 형태로 연산을 하여 axis 키워드 사용
df.subtract(df['R'], axis=0)

# dataframe과 series 연산은 자동으로 두 요소 사이의 index 재정렬
halfrow = df.iloc[0, ::2]
halfrow

df - halfrow

"""
결과
array([[3, 8, 2, 4],
       [2, 6, 4, 8],
       [6, 1, 3, 8]])

array([[ 0,  0,  0,  0],
       [-1, -2,  2,  4],
       [ 3, -7,  1,  4]])

    Q   R  S  T
0   0   0  0  0
1  -1  -2  2  4
2   3  -7  1  4

    Q  R   S   T
0  -5  0  -6  -4
1  -4  0  -2   2
2   5  0   2   7

Q    3
S    2
Name: 0, dtype: int64

      Q    R    S    T
0   0.0  NaN  0.0  NaN
1  -1.0  NaN  2.0  NaN
2   3.0  NaN  1.0  NaN
"""
```

